## Локализация своих скриптов на BASH, часть 2

Это продолжение статьи [Локализация своих скриптов на BASH](https://habr.com/ru/post/539586/)
В ней мы используя массивы и косвенные ссылки научились добавлять в свои скрипты дополнительные языки и переключаться между ними.
В этой статье составим список встроенных языков и зададим выбор языка через меню, построив для этого многоуровневое меню. Чтобы статья не превратилась в один большой кусок кода с описанием каждой строчки, сам код с подробными комментариями я выложу ниже, а здесь затрону только несколько основных моментов.

### Создание меню
В прошлой статье для вывода меню на экран и выбора необходимого пункта мы использовали цикл *for* и оператор выбора *case*. Очевидно, что для создания многоуровнего меню эти шаги нужно будет повторить несколько раз, то есть для каждого подменю. При этом придется заново создавать шапку меню, внешний вид и так далее.
Хороший способ этого избежать - вынести *for*, *case* и *read* в отдельную функцию (назовём её *prints*), а далее будем просто передавать в неё необходимые параметры. Все сценарии, которые будут выполнятся при выборе тех или иных пунктов меню также будут вынесены в соответствующие функции.

Так, чтобы добавить в скрипт новое действие:
- добавляем в языковой массив слова и фразы
- в массив с основным или дополнительным меню вставляем соответствующий пункт и команду вызова функции
- добавляем функцию с необходимым фрагментом кода

Для начала создадим основное меню, которое сразу появится на экране при запуске скрипта:
```bash
menu0=("${lng[3]};main" "${lng[4]};gitadd" "${lng[5]};gitinit" "${lng[2]};options" "${lng[1]};exit")
```

Здесь каждый элемент массива задается двумя параметрами: словесное название необходимого пункта меню, а через разделитель *;* - имя функции, которая будет вызвана. Сделал это для удобства, чтобы не создавать лишний массив для списка команд. Там, куда это все будет передаваться, элемент разделится на две части.
 
Поместим массив в функцию *main*:
```bash
main() {
	# Массив с основным меню
	local menu0=("${lng[3]};main" "${lng[4]};gitadd" "${lng[5]};gitinit" "${lng[2]};options" "${lng[1]};exit")
		
	while true ; do
		
		# Передаем массив в функцию вывода на экран
		# Вторым аргументом идет сообщение, которое отобразится в строке приглашения
		prints "menu0[@]" "${msg[1]}"
	done
}

main
```

При таком подходе создание дополнительных меню немного упрощается, например *options*:
```bash
options() {
	local menu1=("${lng[2]};options" "${lng[7]} [$langset];langmenu" "${lng[1]};exit")
	prints "menu1[@]" "${msg[1]}"
```

Теперь пришло время рассмотреть функцию *prints*, которая выводит все эти меню на экран. Сначала поместим в неё конструкцию, разделяющую элемент на две части. Для разделения задействуем команду вырезания данных *cut*:
```bash
if [[ "$1" == "text" ]] ; then
	# Для текста меню до разделителя
	echo "$2" | cut -d ";" -f 1
	return
elif [[ "$1" == "command" ]] ; then
	# Для команды после разделителя
	echo "$2" | cut -d ";" -f 2
	return
fi
```

Для получения, например, текстового поля вызывать её будем командой *${prints "text" "${menu[0]}"}*  где второй аргумент - сам элемент массива.

***Небольшое, но важное отступление:*** В скрипт я добавил возможность раскрашивать вывод на экран в разные цвета. Отвечающий за это код я поместил в функцию *colors*. Для раскрашивания используются ANSI escape последовательности (вывод *echo -e*) с расширенной палитрой на 256 цветов. 
Также, с прицелом на будущее, я добавил функцию *pwds*, для отображения даты и полного пути текущей директории. Это на случай, если захочется добавить переход по папкам и выбор файлов.
![](Localization_of_Bash_scripts_2_img1.jpg)
Я не буду описывать эти функции, но они будут в конечном коде с подробными комментариями. 

Продолжим рассматривать функцию вывода меню на экран *prints*. Задаем массив из массива, переданного в функцию через аргумент
```bash	
local menu=("${!1}")
```
	
Далее - непосредственно вывод на экран. Выводим дату и текущий путь, затем название меню желтым цветом, название берется из текстовой части 1 элемента массива:
```bash
pwds
colors "title" "---$(prints "text" "${menu[0]}")---"
```
Перебираем в цикле *for* массив, выводим пункты белым цветом, ожидаем ввод значения *read* и обрабатываем нажатие через оператор выбора *case*:
```bash
for (( op=1; op < "${#menu[@]}"; op++ )); do
	colors "item" "$op ) $(prints "text" "${menu[$op]}")"
done
echo ----------
read -s -n1 -p "$(colors "item" "$2: ")" item	
case $item in
	[1-$((${#menu[@]}-1))] ) 
		# Вывод выбранного пункта меню зеленым цветом
		colors "ok" "[$item]->: $(prints "text" "${menu[$item]}")"
		# Вызов функции с фрагментом кода
		$(prints "command" "${menu[$item]}") ;;
		# Немедленное завершение по [q]
		"q" ) echo; exit;;
		# Обработка остальных клавиш и вывод сообщения об ошибке красным цветом
		* ) colors "err" "[$item]->: ${msg[2]}"; sleep 2 ;;
esac	
```
![](Localization_of_Bash_scripts_2_img2.jpg "Так будет выглядеть это меню")


### Построение меню выбора языка
Часть статьи под этим и следующим заголовоком я считаю самой основной. Она получится короткой, но без рассмотренного выше сложно было бы описать последующий функционал.
Итак, для того, чтобы выбирать язык через меню, составим список встроенных языков. Сначала создадим новую функцию *langmenu*.
Заранее хочу отметить, что мы не знаем количество и какие языки присутствуют в скрипте. Мы просто ищем их все. Для этого пробегаемся по текущему скрипту, через *sed* и регулярное выражение находим все имена массивов *language_* и добавляем коды языков в массив. То есть из *language_ru* выкусываем *ru*:
```bash
local lng_sfx=($(sed -r -n -e "s/^\s?+language_(..).+/\1/p" "${0}"))
```
Учитывая, что мы не знали какие языки у нас будут, мы не могли сразу задать массив для передачи его в *prints*. Нужно будет собрать его по частям. Сделаем это там же в *langmenu*:
```bash
langmenu(){
	local lng_sfx=($(sed -r -n -e "s/^\s?+language_(..).+/\1/p" "${0}"))
	local menu2=("${lng[7]};langmenu")
	
	for a in ${lng_sfx[@]} ; do
		local d="language_$a[@]"; d=("${!d}")
		menu2+=("$d;languages set $a")
	done
	
	menu2+=("${lng[1]};exit")
	prints "menu2[@]" "${msg[6]}"
}
```

Здесь мы:
1. Создаем массив для вывода меню
2. В цикле перебираем массив с кодами языков. На каждой итерации создаем косвенную ссылку, чтобы обратиться к 0 элементу соответствующего языкового массива (с записанным нзванием языка). На следующем шаге мы формируем элемент меню: в каждый элемент в текстовую часть добавляем название языка, а через разделитель *;*, в командную часть, добавляем команду вызова функции *languages* и в качестве аргумента ставим код языка. Для английского языка получится *"English;languages set en"*, где *set en* - аргументы для функции *languages*. 
3. После цикла добавляем в массив с меню команду выхода
4. Передаем сформированный массив с языковым меню в функцию вывода на экран *prints*. Вторым аргументом идет сообщение, которое отобразится в строке приглашения

![](Localization_of_Bash_scripts_2_img3.jpg "Меню выбора языка")

### Сохранение языка через настройки
В предыдущей части мы сформировали языковое меню и передали его в функцию *prints*. Которая, в свою очередь, через оператор выбора *case* вызывает функцию *languages*, описанную в [прошлой статье](https://habr.com/ru/post/539586/). При этом в *languages* передаются аргумент *set* и код выбранного языка. Самое время добавить в эту функцию обработку аргументов. Там всего четыре строчки:
```bash
if [ "$1" == "set" ] ; then
		
	# Устанавливаем новый язык из входного аргумента
	langset="$2"
	local df="language_$langset"

	# Выводим сообщение на ТЕУЩЕМ языке что язык изменен,
	# пишем какой выбрали, предлагаем перезапустить программу
	echo
	colors "ok" "${msg[7]} ${!df}. ${msg[8]}"

	# Применяем настройки языка
	languages

	# Выводим сообщение на НОВОМ языке что язык изменен
	# пишем какой выбрали, предлагаем перезапустить программу
	colors "ok" "${msg[7]} ${lng[0]}. ${msg[8]}"
	echo
	# Через регулярное выражение путем изменения файла
	# перезаписываем переменную langset= с кодом языка и выходим
	sed -i -r "/^langset=/s/langset=[\"\']?.*[\"\']?/langset=$langset/" "${0}"
	exit 
fi
```




