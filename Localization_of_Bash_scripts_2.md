## Локализация своих скриптов на BASH, часть 2

Это продолжение статьи [Локализация своих скриптов на BASH](https://habr.com/ru/post/539586/)
В ней мы используя массивы и косвенные ссылки научились добавлять в свои скрипты дополнительные языки и переключаться между ними.
В этой статье составим список встроенных языков и зададим выбор языка через меню. построив для этого многоуровневое меню. Чтобы статья не превратилась в один большой кусок кода с описанием каждой строчки, сам код с подробными комментариями я выложу ниже, а здесь затрону только несколько основных моментов.

### Создание меню
В прошлой статье для вывода меню на экран и выбора необходимого пункта мы использовали цикл *for* и оператор выбора *case*. Очевидно, что для создания многоуровнего меню эти шаги нужно будет повторить несколько раз, то есть для каждого подменю. При этом придется заново создавать шапку меню, внешний вид и так далее.
Хороший способ этого избежать - вынести *for*, *case* и *read* в отдельную функцию (назовём её *prints*), а далее будем просто передавать в неё необходимые параметры. Все сценарии, которые будут выполнятся при выборе тех или иных пунктов меню также будут вынесены в соответствующие функции.

Так, чтобы добавить в скрипт новое действие:
- добавляем в языковой массив слова и фразы
- в массив с основным или дополнительным меню вставляем соответствующий пункт и команду вызова функции
- добавляем функцию с необходимым фрагментом кода

Для начала создадим основное меню, которое сразу появится на экране при запуске скрипта:
```bash
menu0=("${lng[3]};main" "${lng[4]};gitadd" "${lng[5]};gitinit" "${lng[2]};options" "${lng[1]};exit")
```

Здесь каждый элемент массива задается двумя параметрами: словесное название необходимого пункта меню, а через разделитель *;* - имя функции, которая будет вызвана. Сделал это для удобства, чтобы не создавать лишний массив для списка команд. Там, куда это все будет передаваться, элемент разделится на две части.
 
Поместим массив в функцию *main*:
```bash
main() {
	# Массив с основным меню
	local menu0=("${lng[3]};main" "${lng[4]};gitadd" "${lng[5]};gitinit" "${lng[2]};options" "${lng[1]};exit")
		
	while true ; do
		
		# Передаем массив в функцию вывода на экран
		# Вторым аргументом идет сообщение, которое отобразится в строке приглашения
		prints "menu0[@]" "${msg[1]}"
	done
}

main
```

При таком подходе создание дополнительных меню немного упрощается, например *options*:
```bash
options() {
	local menu1=("${lng[2]};options" "${lng[7]} [$langset];langmenu" "${lng[1]};exit")
	prints "menu1[@]" "${msg[1]}"
```

Теперь пришло время рассмотреть функцию *prints*, которая выводит все эти меню на экран. Сначала поместим в неё конструкцию, разделяющую элемент на две части. Для разделения задействуем команду вырезания данных *cut*:
```bash
if [[ "$1" == "text" ]] ; then
	# Для текста меню до разделителя
	echo "$2" | cut -d ";" -f 1
	return
elif [[ "$1" == "command" ]] ; then
	# Для команды после разделителя
	echo "$2" | cut -d ";" -f 2
	return
fi
```

Для получения, например, текстового поля вызывать её будем командой *${prints "text" "${menu[0]}"}*  где второй аргумент - сам элемент массива.

*Небольшое, но важное отступление:* В скрипт я добавил возможность раскрашивать вывод на экран в разные цвета. Отвечающий за это код я поместил в функцию *colors*. Для раскрашивания используются ANSI escape последовательности (вывод *echo -e*) с расширенной палитрой на 256 цветов. 
Также, с прицелом на будущее, я добавил функцию *pwds*, для отображения даты и полного пути текущей директории. Это на случай, если захочется добавить переход по папкам и выбор файлов. 
![](https://habrastorage.org/webt/iy/zh/-k/iyzh-kbgki73dhali5s8owbhwt8.jpeg)
Я не буду описывать эти функции, но они будут в конечном коде с подробными комментариями. 

Продолжим рассматривать функцию вывода меню на экран *prints*:
```bash	
	# Вывод даты и текущего пути
	pwds
	
	# Задаем массив из массива, переданного в функцию	
	local menu=("${!1}")
	
	# Вывод названия меню желтым цветом, название берется
	# из текстовой части 1 элемента массива 	
	colors "title" "---$(prints "text" "${menu[0]}")---"
	
	# Вывод меню на экран
	for (( op=1; op < "${#menu[@]}"; op++ )); do
		
		# Вывод пунктов меню белым цветом, названия берутся
		# из текстовой части соответствующего элемента массива
		colors "item" "$op ) $(prints "text" "${menu[$op]}")"
	done
	
	echo ----------
	
	# Ожидание ввода значения, приглашение выводится белым цветом
	read -s -n1 -p "$(colors "item" "$2: ")" item	
	
	# Оператор выбора
	case $item in
		# Все числа от 1 до размера всего массива минус 1 (так как индексация массива с 0)
		# Вывод выбранного пункта меню зеленым цветом название берется
		# из текстовой части соответствующего элемента массива
		[1-$((${#menu[@]}-1))] ) colors "ok" "[$item]->: $(prints "text" "${menu[$item]}")"
		
		# Вызов функции с набором команд, имя функции берется
		# из командной части соответствующего элемента массива
		$(prints "command" "${menu[$item]}") ;;
		
		# Немедленное завершение по [q]
		"q" ) echo; exit;;
		
		# Обработка остальных клавиш и вывод сообщения об ошибке красным цветом
		* ) colors "err" "[$item]->: ${msg[2]}"; sleep 2 ;;
	esac	
}
```
